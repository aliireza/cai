import subprocess
from colorama import Fore, Style


# This class is used for verifying the functional equivalence of two pieces of code using KLEE, a symbolic execution engine.
class Verification:
    def __init__(self, compiler, ai):
        self.code = ""  # The code to be tested
        # This prompt is used to generate a C++ application that can run two C++ functions with symbolic variables created by KLEE.
        # It will also check if they produce the same output (functional equivalence).
        self.generate_prompt = "Your task is to create a C++ application to run two C++ functions with symbolic variables generated by KLEE and ensure they are functionally equivalent (i.e., the output is the same); you should use assert for the equivalence check. I will provide you with two C++ functions (original code and improved code; each might also have a main function that you may ignore), and you should only return the full code for an application (including the two functions, a wrapper function to call them with symbolic variables and check their equivalance, and a single main() function containing the code to generate symbolic variabels via KLEE) to be able to run KLEE. no text, please; give me the C++ code only. no extern C"
        # This prompt is used to fix any errors reported by KLEE.
        self.verify_prompt = "I got these errors from KLEE. Please fix all of them: "
        self.compiler = compiler  # The compiler to use
        self.ai = ai  # The AI interface to use for generating and fixing the code

    # This method generates the verification code, checks if it is functionally equivalent to the original code, and if not, uses AI to fix it.
    def verify_and_fix(self, original_code, generated_code):
        if (self.code == ''):
            self.generate_code(original_code, generated_code)
        verified, error = self.se_verification()
        if not verified:
            print(Fore.RED + 'Verification Error: ' + Style.RESET_ALL + error)
            self.code = self.ai.submit_task(self.verify_prompt + error, self.code)
            self.verify_and_fix(original_code, generated_code)

    # This method generates the verification code.
    def generate_code(self, original_code, generated_code):
        prompt = self.generate_prompt + "\n\\original code\n" \
            + original_code + "\n\\improved code\n" + generated_code
        print(Fore.YELLOW + "Generating verification code..." + Style.RESET_ALL)
        self.code = self.ai.submit_task(prompt, self.code)
        self.code = self.compiler.check_and_fix(self.code, None, 1, 'klee_code')

    # This method performs the symbolic execution verification using KLEE.
    def se_verification(self):
        klee_command = ['klee', 'klee_code.bc']
        print(Fore.YELLOW + "Running KLEE..." + Style.RESET_ALL)
        process = subprocess.run(klee_command, text=True, capture_output=True)
        if process.returncode != 0:  # If there's a compilation error
            return False, process.stderr
        return True, None
